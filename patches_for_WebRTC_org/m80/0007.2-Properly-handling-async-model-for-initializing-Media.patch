From 8169d726cdc4ef049d6ef64e202e07e3bb58ee3b Mon Sep 17 00:00:00 2001
From: Augusto Righetto <aurighet@microsoft.com>
Date: Wed, 27 May 2020 23:38:26 -0700
Subject: [PATCH] Properly handling async model for initializing MediaCapture
 object

Working around the stride and gap issues with NV12 memory layout
---
 .../windows/device_info_winrt.cc              | 178 ++++++----------
 .../windows/help_functions_winrt.cc           | 199 +++++++++++++++++-
 .../windows/help_functions_winrt.h            |  54 ++++-
 .../windows/video_capture_winrt.cc            |  61 ++++--
 4 files changed, 343 insertions(+), 149 deletions(-)

diff --git a/modules/video_capture/windows/device_info_winrt.cc b/modules/video_capture/windows/device_info_winrt.cc
index 3b2a7aa773..2a7676be1a 100644
--- a/modules/video_capture/windows/device_info_winrt.cc
+++ b/modules/video_capture/windows/device_info_winrt.cc
@@ -26,34 +26,49 @@
 #include "rtc_base/logging.h"
 #include "rtc_base/string_utils.h"
 
-using ABI::Windows::Devices::Enumeration::DeviceClass;
-using ABI::Windows::Devices::Enumeration::DeviceClass_VideoCapture;
-using ABI::Windows::Devices::Enumeration::DeviceInformation;
-using ABI::Windows::Devices::Enumeration::DeviceInformationCollection;
-using ABI::Windows::Devices::Enumeration::IDeviceInformation;
-using ABI::Windows::Devices::Enumeration::IDeviceInformationStatics;
-using ABI::Windows::Foundation::ActivateInstance;
-using ABI::Windows::Foundation::GetActivationFactory;
-using ABI::Windows::Foundation::IAsyncAction;
-using ABI::Windows::Foundation::IAsyncOperation;
-using ABI::Windows::Foundation::IClosable;
-using ABI::Windows::Foundation::Collections::IVectorView;
-using ABI::Windows::Media::Capture::IMediaCapture;
-using ABI::Windows::Media::Capture::IMediaCaptureInitializationSettings;
-using ABI::Windows::Media::Capture::IMediaCaptureInitializationSettings5;
-using ABI::Windows::Media::Capture::MediaCaptureMemoryPreference;
-using ABI::Windows::Media::Capture::MediaStreamType;
-using ABI::Windows::Media::Capture::StreamingCaptureMode;
-using ABI::Windows::Media::Devices::IMediaDeviceController;
-using ABI::Windows::Media::Devices::IVideoDeviceController;
-using ABI::Windows::Media::MediaProperties::IMediaEncodingProperties;
-using ABI::Windows::Media::MediaProperties::IMediaRatio;
-using ABI::Windows::Media::MediaProperties::IVideoEncodingProperties;
-using Microsoft::WRL::ComPtr;
-using Microsoft::WRL::Wrappers::HString;
-using Microsoft::WRL::Wrappers::HStringReference;
-using Microsoft::WRL::Wrappers::RoInitializeWrapper;
-using std::vector;
+using ::ABI::Windows::ApplicationModel::Core::ICoreApplication;
+using ::ABI::Windows::ApplicationModel::Core::ICoreApplicationView;
+using ::ABI::Windows::ApplicationModel::Core::ICoreImmersiveApplication;
+using ::ABI::Windows::Devices::Enumeration::DeviceClass;
+using ::ABI::Windows::Devices::Enumeration::DeviceClass_VideoCapture;
+using ::ABI::Windows::Devices::Enumeration::DeviceInformation;
+using ::ABI::Windows::Devices::Enumeration::DeviceInformationCollection;
+using ::ABI::Windows::Devices::Enumeration::IDeviceInformation;
+using ::ABI::Windows::Devices::Enumeration::IDeviceInformationStatics;
+using ::ABI::Windows::Foundation::ActivateInstance;
+using ::ABI::Windows::Foundation::GetActivationFactory;
+using ::ABI::Windows::Foundation::IAsyncAction;
+using ::ABI::Windows::Foundation::IAsyncActionCompletedHandler;
+using ::ABI::Windows::Foundation::IAsyncOperation;
+using ::ABI::Windows::Foundation::IClosable;
+using ::ABI::Windows::Foundation::Collections::IVectorView;
+using ::ABI::Windows::Media::Capture::IMediaCapture;
+using ::ABI::Windows::Media::Capture::IMediaCaptureInitializationSettings;
+using ::ABI::Windows::Media::Capture::IMediaCaptureInitializationSettings5;
+using ::ABI::Windows::Media::Capture::MediaCaptureMemoryPreference;
+using ::ABI::Windows::Media::Capture::MediaStreamType;
+using ::ABI::Windows::Media::Capture::StreamingCaptureMode;
+using ::ABI::Windows::Media::Devices::IMediaDeviceController;
+using ::ABI::Windows::Media::Devices::IVideoDeviceController;
+using ::ABI::Windows::Media::MediaProperties::IMediaEncodingProperties;
+using ::ABI::Windows::Media::MediaProperties::IMediaRatio;
+using ::ABI::Windows::Media::MediaProperties::IVideoEncodingProperties;
+using ::ABI::Windows::UI::Core::CoreDispatcherPriority;
+using ::ABI::Windows::UI::Core::CoreProcessEventsOption;
+using ::ABI::Windows::UI::Core::ICoreDispatcher;
+using ::ABI::Windows::UI::Core::ICoreWindow;
+using ::ABI::Windows::UI::Core::IDispatchedHandler;
+using ::Microsoft::WRL::Callback;
+using ::Microsoft::WRL::ComPtr;
+using ::Microsoft::WRL::Delegate;
+using ::Microsoft::WRL::FtmBase;
+using ::Microsoft::WRL::Implements;
+using ::Microsoft::WRL::RuntimeClassFlags;
+using ::Microsoft::WRL::Wrappers::Event;
+using ::Microsoft::WRL::Wrappers::HString;
+using ::Microsoft::WRL::Wrappers::HStringReference;
+using ::Microsoft::WRL::Wrappers::RoInitializeWrapper;
+using ::std::vector;
 
 namespace webrtc {
 namespace videocapturemodule {
@@ -68,8 +83,6 @@ struct DeviceInfoWinRTInternal {
 
   ~DeviceInfoWinRTInternal() = default;
 
-  HRESULT Init();
-
   HRESULT GetNumberOfDevices(uint32_t* device_count);
 
   HRESULT GetDeviceName(uint32_t device_number,
@@ -85,71 +98,31 @@ struct DeviceInfoWinRTInternal {
       vector<VideoCaptureCapability>* video_capture_capabilities);
 
  private:
-  HRESULT AssureInitialized();
-
   HRESULT GetDeviceInformationCollection(
       IVectorView<DeviceInformation*>** device_collection);
-
-  HRESULT AssureDeviceInformation();
-
-  RoInitializeWrapper ro_initialize_wrapper_;
-  ComPtr<IDeviceInformationStatics> device_info_statics_;
 };
 
-HRESULT DeviceInfoWinRTInternal::AssureDeviceInformation() {
-  HRESULT hr = S_OK;
-
-  if (!device_info_statics_) {
-    // Get the object containing the DeviceInformation static methods.
-    THR(GetActivationFactory(
-        HStringReference(
-            RuntimeClass_Windows_Devices_Enumeration_DeviceInformation)
-            .Get(),
-        &device_info_statics_));
-  }
-
-Cleanup:
-  return hr;
-}
-
-DeviceInfoWinRTInternal::DeviceInfoWinRTInternal()
-    : ro_initialize_wrapper_(RO_INIT_MULTITHREADED) {}
-
-HRESULT DeviceInfoWinRTInternal::Init() {
-  HRESULT hr;
-
-  THR(AssureInitialized());
-
-Cleanup:
-  return hr;
-}
-
-// Some sample apps don't call DeviceInfoImpl::Init before using the class.
-// All public methods of this class should assure its initialization.
-HRESULT DeviceInfoWinRTInternal::AssureInitialized() {
-  HRESULT hr = S_OK;
-
-  // Checks if Windows runtime initialized successfully.
-  // Pay attention if ro_initialize_wrapper_ is returning RPC_E_CHANGED_MODE.
-  // It means device_info_winrt is being called from an apartment thread (STA)
-  // instead of multithreaded (MTA). Usually this means device_info_winrt is
-  // being called from the UI thread.
-  THR((HRESULT)ro_initialize_wrapper_);
-
-  THR(AssureDeviceInformation());
-
-Cleanup:
-  return hr;
-}
+DeviceInfoWinRTInternal::DeviceInfoWinRTInternal() {}
 
 HRESULT DeviceInfoWinRTInternal::GetDeviceInformationCollection(
     IVectorView<DeviceInformation*>** device_collection) {
   HRESULT hr;
+  ComPtr<IActivationFactory> activation_factory;
+  ComPtr<IDeviceInformationStatics> device_info_statics;
   ComPtr<IAsyncOperation<DeviceInformationCollection*>>
       async_op_device_info_collection;
 
+  // Get the object containing the DeviceInformation static methods.
+  THR(GetActivationFactory(
+      HStringReference(
+          RuntimeClass_Windows_Devices_Enumeration_DeviceInformation)
+          .Get(),
+      &activation_factory));
+
+  THR(activation_factory.As<IDeviceInformationStatics>(&device_info_statics));
+
   // Call FindAllAsync and then start the async operation.
-  THR(device_info_statics_->FindAllAsyncDeviceClass(
+  THR(device_info_statics->FindAllAsyncDeviceClass(
       DeviceClass_VideoCapture, &async_op_device_info_collection));
 
   // Block and suspend thread until the async operation finishes or timeouts.
@@ -166,9 +139,6 @@ HRESULT DeviceInfoWinRTInternal::GetNumberOfDevices(uint32_t* device_count) {
   HRESULT hr;
   ComPtr<IVectorView<DeviceInformation*>> device_info_collection;
 
-  // Assures class has been properly initialized.
-  THR(AssureInitialized());
-
   THR(GetDeviceInformationCollection(
       device_info_collection.ReleaseAndGetAddressOf()));
   THR(device_info_collection->get_Size(device_count));
@@ -190,9 +160,6 @@ HRESULT DeviceInfoWinRTInternal::GetDeviceName(
   ComPtr<IVectorView<DeviceInformation*>> device_info_collection;
   ComPtr<IDeviceInformation> device_info;
 
-  // Assures class has been properly initialized.
-  THR(AssureInitialized());
-
   // Gets the device information collection synchronously
   THR(GetDeviceInformationCollection(
       device_info_collection.ReleaseAndGetAddressOf()));
@@ -281,41 +248,26 @@ HRESULT DeviceInfoWinRTInternal::CreateCapabilityMap(
     const wchar_t* device_unique_id,
     vector<VideoCaptureCapability>* video_capture_capabilities) {
   HRESULT hr;
-  ComPtr<IMediaCaptureInitializationSettings> init_settings;
-  ComPtr<IMediaCaptureInitializationSettings5> init_settings5;
+
   ComPtr<IMediaCapture> media_capture;
   ComPtr<IClosable> media_capture_closable;
   ComPtr<IAsyncAction> async_action;
   ComPtr<IVideoDeviceController> video_device_controller;
   ComPtr<IMediaDeviceController> media_device_controller;
   ComPtr<IVectorView<IMediaEncodingProperties*>> stream_capabilities;
+
+  ComPtr<IAsyncAction> async_action_media_capture;
+  Event event_wait_for_media_capture_async_action;
+  Event event_wait_for_media_capture_async_action_complition;
+
   HStringReference device_id(device_unique_id);
   unsigned int stream_capabilities_size;
   vector<VideoCaptureCapability> device_caps;
 
   THR(video_capture_capabilities ? S_OK : E_INVALIDARG);
 
-  // Assures class has been properly initialized.
-  THR(AssureInitialized());
-
-  THR(ActivateInstance(
-      HStringReference(
-          RuntimeClass_Windows_Media_Capture_MediaCaptureInitializationSettings)
-          .Get(),
-      &init_settings));
-  THR(init_settings.As<IMediaCaptureInitializationSettings5>(&init_settings5));
-  THR(init_settings5->put_MemoryPreference(
-      MediaCaptureMemoryPreference::MediaCaptureMemoryPreference_Cpu));
-  THR(init_settings->put_VideoDeviceId(device_id.Get()));
-
-  THR(ActivateInstance(
-      HStringReference(RuntimeClass_Windows_Media_Capture_MediaCapture).Get(),
-      &media_capture));
-
-  THR(media_capture->InitializeWithSettingsAsync(init_settings.Get(),
-                                                 &async_action));
-
-  THR(WaitForAsyncAction(async_action));
+  THR(GetMediaCaptureForDevice(device_id.Get(),
+                               media_capture.ReleaseAndGetAddressOf()));
 
   THR(media_capture->get_VideoDeviceController(&video_device_controller));
   THR(video_device_controller.As<IMediaDeviceController>(
@@ -389,7 +341,7 @@ DeviceInfoWinRT::~DeviceInfoWinRT() {
 }
 
 int32_t DeviceInfoWinRT::Init() {
-  return SUCCEEDED(Impl(device_info_internal_)->Init()) ? 0 : -1;
+  return 0;
 }
 
 uint32_t DeviceInfoWinRT::NumberOfDevices() {
diff --git a/modules/video_capture/windows/help_functions_winrt.cc b/modules/video_capture/windows/help_functions_winrt.cc
index 709c685b26..b3f5de59f2 100644
--- a/modules/video_capture/windows/help_functions_winrt.cc
+++ b/modules/video_capture/windows/help_functions_winrt.cc
@@ -10,19 +10,175 @@
 
 #include "modules/video_capture/windows/help_functions_winrt.h"
 
-using ABI::Windows::Foundation::AsyncStatus;
-using ABI::Windows::Foundation::IAsyncAction;
-using ABI::Windows::Foundation::IAsyncActionCompletedHandler;
-using ABI::Windows::Foundation::IAsyncInfo;
-using ABI::Windows::Media::MediaProperties::IMediaRatio;
-using Microsoft::WRL::Callback;
-using Microsoft::WRL::ComPtr;
-using Microsoft::WRL::Wrappers::Event;
-using Microsoft::WRL::Wrappers::HString;
+#include <Windows.ApplicationModel.core.h>
+#include <Windows.ApplicationModel.h>
+
+using ::ABI::Windows::ApplicationModel::Core::ICoreApplication;
+using ::ABI::Windows::ApplicationModel::Core::ICoreApplicationView;
+using ::ABI::Windows::ApplicationModel::Core::ICoreImmersiveApplication;
+using ::ABI::Windows::Foundation::ActivateInstance;
+using ::ABI::Windows::Foundation::AsyncStatus;
+using ::ABI::Windows::Foundation::GetActivationFactory;
+using ::ABI::Windows::Foundation::IAsyncAction;
+using ::ABI::Windows::Foundation::IAsyncActionCompletedHandler;
+using ::ABI::Windows::Foundation::IAsyncInfo;
+using ::ABI::Windows::Media::Capture::IMediaCapture;
+using ::ABI::Windows::Media::Capture::IMediaCaptureFailedEventArgs;
+using ::ABI::Windows::Media::Capture::IMediaCaptureFailedEventHandler;
+using ::ABI::Windows::Media::Capture::IMediaCaptureInitializationSettings;
+using ::ABI::Windows::Media::Capture::IMediaCaptureInitializationSettings5;
+using ::ABI::Windows::Media::Capture::MediaCaptureMemoryPreference;
+using ::ABI::Windows::Media::Capture::StreamingCaptureMode;
+using ::ABI::Windows::Media::MediaProperties::IMediaRatio;
+using ::ABI::Windows::UI::Core::CoreDispatcherPriority;
+using ::ABI::Windows::UI::Core::CoreProcessEventsOption;
+using ::ABI::Windows::UI::Core::ICoreDispatcher;
+using ::ABI::Windows::UI::Core::ICoreWindow;
+using ::ABI::Windows::UI::Core::IDispatchedHandler;
+using ::Microsoft::WRL::AgileRef;
+using ::Microsoft::WRL::Callback;
+using ::Microsoft::WRL::ComPtr;
+using ::Microsoft::WRL::Delegate;
+using ::Microsoft::WRL::FtmBase;
+using ::Microsoft::WRL::Implements;
+using ::Microsoft::WRL::RuntimeClassFlags;
+using ::Microsoft::WRL::Wrappers::Event;
+using ::Microsoft::WRL::Wrappers::HString;
+using ::Microsoft::WRL::Wrappers::HStringReference;
 
 namespace webrtc {
 namespace videocapturemodule {
 
+HRESULT GetMediaCaptureForDevice(HSTRING device_id,
+                                  IMediaCapture** ppMediaCapture) {
+  HRESULT hr;
+
+  ComPtr<ICoreDispatcher> main_view_dispatcher;
+  ComPtr<IAsyncAction> async_action_ui_dispatcher;
+  ComPtr<IAsyncAction> async_action_media_capture;
+  ComPtr<IMediaCapture> media_capture;
+  AgileRef media_capture_agile;
+  AgileRef async_action_media_capture_agile;
+  Event event_wait_for_media_capture_async_action;
+  Event event_wait_for_media_capture_async_action_completion;
+  boolean has_thread_access;
+
+  // Acquires the main view dispacther (UI thread).
+  THR(GetMainViewDispatcher(&main_view_dispatcher));
+
+  // We'll be dispatching and waiting for code from the UI thread.
+  // Let's make sure this is not the UI thread.
+  THR(main_view_dispatcher->get_HasThreadAccess(&has_thread_access));
+  THR(has_thread_access ? E_FAIL : S_OK);
+
+  // The media capture device has to be initialized in the UI thread.
+  // The following event is used for letting this thread know that
+  // async_action_media_capture has been created.
+  event_wait_for_media_capture_async_action =
+      Event(::CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET,
+                            WRITE_OWNER | EVENT_ALL_ACCESS));
+  THR(event_wait_for_media_capture_async_action.IsValid()
+          ? S_OK
+          : HRESULT_FROM_WIN32(GetLastError()));
+
+  THR(ActivateInstance(
+      HStringReference(RuntimeClass_Windows_Media_Capture_MediaCapture).Get(),
+      media_capture.ReleaseAndGetAddressOf()));
+
+  THR(media_capture.AsAgile(&media_capture_agile));
+
+  // Dispatches the media capture initialization to the main view
+  // dispatcher.
+  THR(main_view_dispatcher->RunAsync(
+      CoreDispatcherPriority::CoreDispatcherPriority_Normal,
+      Callback<Implements<RuntimeClassFlags<Delegate>, IDispatchedHandler,
+                          FtmBase>>([&event_wait_for_media_capture_async_action,
+                                     &async_action_media_capture_agile,
+                                     &media_capture_agile,
+                                     &device_id]() -> HRESULT {
+        HRESULT hr;
+
+        ComPtr<IMediaCapture> media_capture;
+        ComPtr<IAsyncAction> media_capture_async;
+        ComPtr<IMediaCaptureInitializationSettings> init_settings;
+        ComPtr<IMediaCaptureInitializationSettings5> init_settings5;
+
+        THR(media_capture_agile.As(&media_capture));
+
+        // Creates the settings used to select which capture device will be
+        // used.
+        THR(ActivateInstance(
+            HStringReference(
+                RuntimeClass_Windows_Media_Capture_MediaCaptureInitializationSettings)
+                .Get(),
+            &init_settings));
+        THR(init_settings->put_StreamingCaptureMode(
+            StreamingCaptureMode::StreamingCaptureMode_AudioAndVideo));
+        THR(init_settings.As<IMediaCaptureInitializationSettings5>(
+            &init_settings5));
+        THR(init_settings5->put_MemoryPreference(
+            MediaCaptureMemoryPreference::MediaCaptureMemoryPreference_Cpu));
+        THR(init_settings->put_VideoDeviceId(device_id));
+
+        THR(media_capture->InitializeWithSettingsAsync(init_settings.Get(),
+                                                       &media_capture_async));
+
+        THR(media_capture_async.AsAgile(&async_action_media_capture_agile));
+
+      Cleanup:
+        ::SetEvent(event_wait_for_media_capture_async_action.Get());
+        return hr;
+      }).Get(),
+      &async_action_ui_dispatcher));
+
+  // Waits for the UI thread to create async_action_media_capture.
+  THR(::WaitForSingleObjectEx(event_wait_for_media_capture_async_action.Get(),
+                              INFINITE, FALSE) == WAIT_OBJECT_0
+          ? S_OK
+          : E_FAIL);
+
+  // Waits for user to approve (or not) access to the microphone and
+  // camera.
+  event_wait_for_media_capture_async_action_completion =
+      Event(::CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET,
+                            WRITE_OWNER | EVENT_ALL_ACCESS));
+  THR(event_wait_for_media_capture_async_action_completion.IsValid()
+          ? S_OK
+          : HRESULT_FROM_WIN32(GetLastError()));
+
+  // Waits until user grant (or deny) access to the camera.
+  THR(async_action_media_capture_agile.As(&async_action_media_capture));
+  THR(async_action_media_capture->put_Completed(
+      Callback<IAsyncActionCompletedHandler>(
+          [&event_wait_for_media_capture_async_action_completion](
+              IAsyncAction*, AsyncStatus async_status) -> HRESULT {
+            HRESULT hr;
+
+            // Checks if user granted permission to access the camera.
+            THR(async_status == AsyncStatus::Completed ? S_OK : E_ACCESSDENIED);
+
+          Cleanup:
+            ::SetEvent(
+                event_wait_for_media_capture_async_action_completion.Get());
+
+            return hr;
+          })
+          .Get()));
+
+  THR(::WaitForSingleObjectEx(
+          event_wait_for_media_capture_async_action_completion.Get(), INFINITE,
+          FALSE) == WAIT_OBJECT_0
+          ? S_OK
+          : E_FAIL);
+
+  // User granted access, good to go.
+  ReleaseInterface(ppMediaCapture);
+  *ppMediaCapture = media_capture.Detach();
+
+Cleanup:
+  return hr;
+}
+
 uint32_t SafelyComputeMediaRatio(IMediaRatio* ratio_no_ref) {
   HRESULT hr;
   uint32_t numerator, denominator, media_ratio = 0;
@@ -70,6 +226,31 @@ VideoType ToVideoType(const HString& sub_type) {
   return converted_type;
 }
 
+HRESULT GetMainViewDispatcher(ICoreDispatcher** main_view_dispatcher) {
+  HRESULT hr;
+
+  ComPtr<IActivationFactory> activation_factory;
+  ComPtr<ICoreApplication> coreApplication;
+  ComPtr<ICoreImmersiveApplication> immersiveApplication;
+  ComPtr<ICoreApplicationView> applicationView;
+  ComPtr<ICoreWindow> coreWindow;
+
+  THR(GetActivationFactory(
+      HStringReference(
+          RuntimeClass_Windows_ApplicationModel_Core_CoreApplication)
+          .Get(),
+      &activation_factory));
+
+  THR(activation_factory.As<ICoreApplication>(&coreApplication));
+  THR(coreApplication.As<ICoreImmersiveApplication>(&immersiveApplication));
+  THR(immersiveApplication->get_MainView(&applicationView));
+  THR(applicationView->get_CoreWindow(&coreWindow));
+  THR(coreWindow->get_Dispatcher(main_view_dispatcher));
+
+Cleanup:
+  return hr;
+}
+
 HRESULT WaitForAsyncAction(ComPtr<IAsyncAction> async_action) {
   HRESULT hr, hr_async_error;
   const DWORD timeout_ms = 2000;
diff --git a/modules/video_capture/windows/help_functions_winrt.h b/modules/video_capture/windows/help_functions_winrt.h
index 0216d9b0ce..6b81bfc977 100644
--- a/modules/video_capture/windows/help_functions_winrt.h
+++ b/modules/video_capture/windows/help_functions_winrt.h
@@ -13,6 +13,7 @@
 
 #include <windows.foundation.h>
 #include <windows.media.mediaproperties.h>
+#include <windows.ui.core.h>
 #include <wrl/client.h>
 #include <wrl/event.h>
 #include <wrl/wrappers/corewrappers.h>
@@ -20,15 +21,51 @@
 #include <cassert>
 
 #include "modules/video_capture/video_capture_defines.h"
+#include "rtc_base/logging.h"
 
 // Evaluates an expression returning a HRESULT.
 // It jumps to a label named Cleanup on failure.
-#define THR(expr)   \
-  do {              \
-    hr = (expr);    \
-    if (FAILED(hr)) \
-      goto Cleanup; \
+#ifdef _DEBUG
+#define THR(expr)                                           \
+  do {                                                      \
+    hr = (expr);                                            \
+    if (FAILED(hr)) {                                       \
+      RTC_LOG(LS_ERROR) << "HR: " << hr;                    \
+      RTC_LOG(LS_ERROR) << __FUNCTION__ << ":" << __LINE__; \
+      __debugbreak();                                       \
+      goto Cleanup;                                         \
+    }                                                       \
   } while (false)
+#else
+#define THR(expr)     \
+  do {                \
+    hr = (expr);      \
+    if (FAILED(hr)) { \
+      goto Cleanup;   \
+    }                 \
+  } while (false)
+#endif
+
+template <typename T>
+void ReleaseInterface(T** ppInterface) {
+  if ((*ppInterface)) {
+    (*ppInterface)->Release();
+    (*ppInterface) = nullptr;
+  }
+}
+
+template <typename T, typename U>
+void ReplaceInterface(T** ppInterface, U* pSource) {
+  if ((*ppInterface)) {
+    (*ppInterface)->Release();
+  }
+
+  (*ppInterface) = pSource;
+
+  if (pSource) {
+    pSource->AddRef();
+  }
+}
 
 namespace webrtc {
 namespace videocapturemodule {
@@ -38,6 +75,13 @@ uint32_t SafelyComputeMediaRatio(
 
 VideoType ToVideoType(const Microsoft::WRL::Wrappers::HString& sub_type);
 
+HRESULT GetMainViewDispatcher(
+    ::ABI::Windows::UI::Core::ICoreDispatcher** dispatcher);
+
+HRESULT GetMediaCaptureForDevice(
+    HSTRING device_id,
+    ::ABI::Windows::Media::Capture::IMediaCapture** pp_media_capture);
+
 HRESULT WaitForAsyncAction(
     Microsoft::WRL::ComPtr<ABI::Windows::Foundation::IAsyncAction>
         async_action);
diff --git a/modules/video_capture/windows/video_capture_winrt.cc b/modules/video_capture/windows/video_capture_winrt.cc
index 5aa3541b34..4a8a597bdf 100644
--- a/modules/video_capture/windows/video_capture_winrt.cc
+++ b/modules/video_capture/windows/video_capture_winrt.cc
@@ -68,6 +68,7 @@ using ABI::Windows::Media::Capture::Frames::MediaFrameReaderStartStatus;
 using ABI::Windows::Media::Capture::Frames::MediaFrameSource;
 using ABI::Windows::Media::Capture::Frames::MediaFrameSourceKind;
 using ABI::Windows::Media::MediaProperties::IMediaRatio;
+using ABI::Windows::Graphics::Imaging::BitmapPlaneDescription;
 using Microsoft::WRL::Callback;
 using Microsoft::WRL::ComPtr;
 using Microsoft::WRL::Wrappers::HString;
@@ -141,9 +142,6 @@ Cleanup:
 
 HRESULT VideoCaptureWinRTInternal::InitCamera(const wchar_t* device_unique_id) {
   HRESULT hr;
-  ComPtr<IMediaCaptureInitializationSettings> settings;
-  ComPtr<IMediaCaptureInitializationSettings5> settings5;
-  ComPtr<IAsyncAction> async_action;
   HStringReference device_id(device_unique_id);
 
   if (media_capture_) {
@@ -153,24 +151,9 @@ HRESULT VideoCaptureWinRTInternal::InitCamera(const wchar_t* device_unique_id) {
     THR(StopCapture() == 0 ? S_OK : E_FAIL);
     THR(closable_media_capture->Close());
   }
-  THR(ActivateInstance(
-      HStringReference(RuntimeClass_Windows_Media_Capture_MediaCapture).Get(),
-      media_capture_.ReleaseAndGetAddressOf()));
-
-  // Defines the settings to be used the camera
-  THR(ActivateInstance(
-      HStringReference(
-          RuntimeClass_Windows_Media_Capture_MediaCaptureInitializationSettings)
-          .Get(),
-      &settings));
-  THR(settings.As(&settings5));
-  THR(settings5->put_MemoryPreference(
-      MediaCaptureMemoryPreference::MediaCaptureMemoryPreference_Cpu));
-  THR(settings->put_VideoDeviceId(device_id.Get()));
 
-  THR(media_capture_->InitializeWithSettingsAsync(settings.Get(),
-                                                  &async_action));
-  THR(WaitForAsyncAction(async_action));
+  THR(GetMediaCaptureForDevice(device_id.Get(),
+                                media_capture_.ReleaseAndGetAddressOf()));
 
 Cleanup:
   return hr;
@@ -183,7 +166,8 @@ HRESULT VideoCaptureWinRTInternal::StartCapture(
   ComPtr<IMediaCapture5> media_capture5;
   ComPtr<IMapView<HSTRING, MediaFrameSource*>> frame_sources;
   ComPtr<IIterable<IKeyValuePair<HSTRING, MediaFrameSource*>*>> iterable;
-  ComPtr<IIterator<IKeyValuePair<HSTRING, MediaFrameSource*>*>> frame_source_iterator;
+  ComPtr<IIterator<IKeyValuePair<HSTRING, MediaFrameSource*>*>>
+      frame_source_iterator;
   ComPtr<IAsyncOperation<MediaFrameReader*>> async_operation;
   ComPtr<IAsyncOperation<MediaFrameReaderStartStatus>>
       async_media_frame_reader_start_status;
@@ -360,9 +344,12 @@ HRESULT VideoCaptureWinRTInternal::FrameArrived(
   ComPtr<IMemoryBuffer> memory_buffer;
   ComPtr<IMemoryBufferReference> memory_buffer_reference;
   ComPtr<IMemoryBufferByteAccess> memory_buffer_byte_access;
+  BitmapPlaneDescription bitmap_plane_description_y;
+  BitmapPlaneDescription bitmap_plane_description_uv;
   HString video_subtype;
   uint8_t* bitmap_content;
   uint32_t bitmap_capacity;
+  int32_t plane_count;
 
   THR(media_frame_reader->TryAcquireLatestFrame(&media_frame_reference));
 
@@ -384,15 +371,45 @@ HRESULT VideoCaptureWinRTInternal::FrameArrived(
     frameInfo.interlaced = false;
 
     THR(video_media_frame->get_SoftwareBitmap(&software_bitmap));
+
     THR(software_bitmap->LockBuffer(
         BitmapBufferAccessMode::BitmapBufferAccessMode_Read, &bitmap_buffer));
+
+    THR(bitmap_buffer->GetPlaneCount(&plane_count));
+    THR(plane_count == 2 ? S_OK : E_FAIL);
+    THR(bitmap_buffer->GetPlaneDescription(0, &bitmap_plane_description_y));
+    THR(bitmap_buffer->GetPlaneDescription(1, &bitmap_plane_description_uv));
+
     THR(bitmap_buffer.As(&memory_buffer));
     THR(memory_buffer->CreateReference(&memory_buffer_reference));
     THR(memory_buffer_reference.As(&memory_buffer_byte_access));
     THR(memory_buffer_byte_access->GetBuffer(&bitmap_content,
                                              &bitmap_capacity));
 
-    pfn_incoming_frame_(bitmap_content, bitmap_capacity, frameInfo, 0);
+    // hack(auright): The following hack works around the limitations of 
+    // libWebRTC memory representations for YUV planar images. Windows::Media::Capture allows
+    // representing NV12 images with strides greater than YUV widths and with a gap between
+    // the Y plane and the UV planes. The following workaround compresses the image in memory
+    // by removing the gap between planes and making the stride equal to widths. This is a
+    // temporary hack until the implementation with Media Foundation is in place.
+    if ((bitmap_plane_description_y.Width != bitmap_plane_description_y.Stride) ||
+        (bitmap_plane_description_uv.Width * 2 != bitmap_plane_description_uv.Stride) ||
+        (bitmap_plane_description_y.Width * bitmap_plane_description_y.Height != bitmap_plane_description_uv.StartIndex)) {
+        uint8_t* pContiguousYUV = bitmap_content + bitmap_plane_description_y.Width;
+        for (auto i = 1; i < bitmap_plane_description_y.Height; ++i) {
+          memcpy(pContiguousYUV, bitmap_content + (i * bitmap_plane_description_y.Stride), bitmap_plane_description_y.Width);
+          pContiguousYUV += bitmap_plane_description_y.Width;
+        }
+        for (auto i = 0; i < bitmap_plane_description_uv.Height; ++i) {
+          memcpy(pContiguousYUV, bitmap_content + bitmap_plane_description_uv.StartIndex + (i * bitmap_plane_description_uv.Stride), bitmap_plane_description_uv.Width * 2);
+          pContiguousYUV += bitmap_plane_description_uv.Width * 2;
+        }
+
+        pfn_incoming_frame_(bitmap_content, pContiguousYUV - bitmap_content, frameInfo, 0);
+    } else {
+      pfn_incoming_frame_(bitmap_content, bitmap_capacity, frameInfo, 0);
+    }
+
   }
 
 Cleanup:
-- 
2.26.2.windows.1

